import Foundation
import Combine
import EventKit

class CalendarManager: ObservableObject {
    private let store = EKEventStore()
    
    @Published var isAuthorized: Bool = false
    @Published var authStatus: EKAuthorizationStatus = .notDetermined
    
    init() {
        // Do not request permission on init
        updateAuthorizationStatus()
    }
    
    func updateAuthorizationStatus() {
        let status = EKEventStore.authorizationStatus(for: .event)
        self.authStatus = status
        
        switch status {
        case .authorized, .fullAccess:
            self.isAuthorized = true
        default:
            self.isAuthorized = false
        }
    }
    
    func requestAccess() {
        store.requestFullAccessToEvents { [weak self] granted, error in
            DispatchQueue.main.async {
                self?.updateAuthorizationStatus()
            }
        }
    }
    
    func createInTheGapCalendar() -> EKCalendar? {
        // Check if calendar already exists
        let calendars = store.calendars(for: .event)
        if let existing = calendars.first(where: { $0.title == "InTheGap" }) {
            return existing
        }
        
        // Create new calendar
        let newCalendar = EKCalendar(for: .event, eventStore: store)
        newCalendar.title = "InTheGap"
        newCalendar.cgColor = CGColor(red: 1.0, green: 0.498, blue: 0.314, alpha: 1.0)
        
        // Find best source (usually iCloud or Local)
        let sources = store.sources
        if let iCloud = sources.first(where: { $0.sourceType == .calDAV && $0.title == "iCloud" }) {
            newCalendar.source = iCloud
        } else if let local = sources.first(where: { $0.sourceType == .local }) {
            newCalendar.source = local
        } else {
             newCalendar.source = store.defaultCalendarForNewEvents?.source
        }
        
        do {
            try store.saveCalendar(newCalendar, commit: true)
            return newCalendar
        } catch {
            print("Error saving calendar: \(error)")
            return nil
        }
    }
    
    func addEvent(title: String, startDate: Date, duration: TimeInterval, notes: String? = nil) {
        guard let calendar = createInTheGapCalendar() else { return }
        
        let event = EKEvent(eventStore: store)
        event.title = title
        event.startDate = startDate
        event.endDate = startDate.addingTimeInterval(duration)
        event.calendar = calendar
        event.notes = notes ?? "Generated by InTheGap AI Learning Planner"
        
        let alarm = EKAlarm(relativeOffset: -600) // 10 minutes before
        event.addAlarm(alarm)
        
        do {
            try store.save(event, span: .thisEvent)
        } catch {
            print("Error saving event: \(error)")
        }
    }
    func fetchEvents(start: Date, end: Date) -> [EKEvent] {
        let calendars = store.calendars(for: .event)
        let predicate = store.predicateForEvents(withStart: start, end: end, calendars: calendars)
        return store.events(matching: predicate)
    }
}

